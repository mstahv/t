:sectnums:

= Vaadin tutorial

This is tutorial that gives you an overview how you can use Vaadin Framework to
build web UI's for your Java applications. All you need to start with is an IDE
like Eclipse and Java JDK 8. Only basic programming skills are required.
Although the tutorial is built for Eclipse users, advanced Java developers can
use their IDE of choice and adapt the different parts to their IDE.

We'll build a simple customer management system. It is not a real app, but just
a really simple UI layer for an in-memory "backend". We'll just cover really
basic Vaadin development, but you can use the result as a basis for more Vaadin
experiments with add-ons, making custom theme, optimizing the result for mobile
support or adding other views.

== Creating a project using archetype

As a starting point for the application we'll use Maven archetype called
vaadin-archetype-application. Maven archetypes are projects stubs with basic
build script and some example code.

Start by choosing _File->New->Project_ to open the project creation wizard. In
the dialog you'll find a group _Maven_ and _Maven project_. Next wizard page is
ok with defaults, but from third page you'll need to choose
_vaadin-archetype-application_ archetype.

image::createMavenProject.png[Create a new Maven built Vaadin project.]

You can try to find it using the  filtering function, but in some cases Eclipse
hasn't yet indexed the archetype catalog, so you might need to manually add the
archetype details with _Add Archetype_ button. The Group Id is "com.vaadin",
Artifact Id is _vaadin-archetype-application_ and as a version you can use
the latest Vaadin version, at the time of writing _7.6.0_.

On next wizard page, type in _my.vaadin_ as Group Id, _app_ as Artifact Id and
click _Finish_. If this is your first ever Vaadin app, creating a project might
take a while, depending of the speed of your network, as Vaadin libraries and
couple of dependencies are being downloaded.

Right click on the created project and choose _Run as -> Maven Install_. This
will initiate a full build of your application and finally create a war file to
the "target" directory that you can deploy to your application server. As the
project as set up a basis for add-on usage and contains a project specific
theme, the first build will take a while.

To test this first Vaadin application, right click on the project and choose
_Debug as -> Maven build..._. Debug mode is slightly slower, but it often helps
you to figure out what is happening in our application. Type _jetty:run_ to the
_Goals_ input and _Run in jetty_ to the _Name_ input.

image::debugAsMavenBuild.png[Starting server using Maven target]

To make debugging work properly, add your Java project to the source lookup path from the source tab.

image::debugAsMavenBuildAddSources.png[Adding sources for debugging]

Clicking _Debug_ will download a small server to host your application (if not
cached to your local Maven repository), and use it to host your first Vaadin
application. Once the server has started, open your browser to address
"http://localhost:8080/" to see the app running.

The UI code (and Servlet declaration) used by the app stub can be found from the
MyUI.java file. You can read it through and see how it works. If you make some
changes to the code, the jetty server will notice the changes and in a couple of
seconds most changes are automatically deployed. Reloading a browser will show
the changes.

You can also double click the line number in the Java editor, e.g. on click
listener. This will add a breakpoint to the selected line. If you then use your
browser to click the button, the execution will stop on the line and you can
inspect the variables and step through the execution. Clicking on _play_ icon in
toolbar will continue the execution, double clicking on breakpoint row again
will disable the breakpoint.

image::debugInBreakPointVariable.png[Execution in a break point in button click listener]

Clicking the red square in the Console view will terminate the server process.
You can restart it easily form the run/debug history.

== Adding demo "backend"

Before getting more into real Vaadin development, let's introduce some domain
objects and a "fake backend". In a real world application you'll most likely
have something similar, implemented with for example JPA and EJB or Spring based
service.

Copy following three classes from the github. You can either download the java
files and move to your project or just copy the content from your browser and
paste them in Eclipse over the "my.vaadin" package.

 * CustomerStatus - this is a simple enum class
 * Customer - this is the main domain object, basic Java bean, that we'll be
   using in our example
 * CustomerService - this is a simple facade via you can request and modify
   Customer instances

The actual implementation of these classes is not relevant for this tutorial.

== Listing entities with Grid

Typically, when you start building data centric applications, the first thing
you want to do is list your data. There are several components in Vaadin to do
this. In this example we'll use Grid component for tabular presentation of our
customers.

We'll start by introducing a Grid field to the MyUI class. We could of course just
introduce the Grid as a variable in the init method, but we'll most likely want
to refer to it later. Also, let's get a reference to the CustomerService.

[source,java]
----
public class MyUI extends UI {

    // Add these lines:
  	CustomerService service = CustomerService.getInstance();
  	Grid grid = new Grid();

  	@Override
  	protected void init(VaadinRequest vaadinRequest) {
    //....
----

If you are new to Java development, you probably got scared of the a red
compilation error for the line where Grid got introduced, due to a missing
import. This is easily fixed by Eclipse using _Source -> Organize Imports_
command, learn its shortcut, you'll be using it a lot in Java development. In
possible class name collisions, choose the class from com.vaadin.ui package if
you want to import core Vaadin UI classes like Grid.

To simply list all properties of all found Customer objects, replace the init
method with following snippet:

[source,java]
----
@Override
protected void init(VaadinRequest vaadinRequest) {
    final VerticalLayout layout = new VerticalLayout();

    // add Grid to the layout
    layout.addComponents(grid);

    // fetch list of Customers from service and assing it to Grid
    List<Customer> customers = service.findAll();
    grid.setContainerDataSource(new BeanItemContainer<>(Customer.class, customers));

    layout.setMargin(true);
    setContent(layout);
}
----

As we'll want to refresh the listing from various places in our application,
extract the customer listing part into its own "updateList" method with public
modifier. You can let Eclipse help here by selecting the relevant lines and
using "quick fix" feature (CTRL-1 or CMD-1 on macs).

If you try the application now, you'll see the quite many properties of the
customers are shown in the listing. To limit the visible properties configure
the Grid using setColumns method to only show "firstName", "lastName" and
"email" fields.

At this point the body of MyUI class should look like this (servlet declaration
omitted):

[source,java]
----
// Add these lines:
CustomerService service = CustomerService.getInstance();
Grid grid = new Grid();

@Override
protected void init(VaadinRequest vaadinRequest) {
    final VerticalLayout layout = new VerticalLayout();

    grid.setColumns("firstName", "lastName", "email");
    // add Grid to the layout
    layout.addComponent(grid);

    updateList();

    layout.setMargin(true);
    setContent(layout);
}

public void updateList() {
    // fetch list of Customers from service and assing it to Grid
    List<Customer> customers = service.findAll();
    grid.setContainerDataSource(new BeanItemContainer<>(Customer.class, customers));
}
----


== Creating live filtering for entities

A proper search is feature of every modern application and it is also a nice
Vaadin development exercise. Let's add a filtering function to the listing we
did in the previous step.

We'll start by introducing a TextField component as a field to our UI class:

[source,java]
    TextField filterText = new TextField();

In the main method, configure the text field to contain a helpful input prompt
and add a text change listener to the field.

[source,java]
filterText.setInputPrompt("filter by name...");
filterText.addTextChangeListener(e -> {
	grid.setContainerDataSource(new BeanItemContainer<>(Customer.class, service.findAll(e.getText())));
});

The text change listener is another listener (in addition to more commonly used
ValueChangeListener) you can use with text fields in Vaadin. It is fired lazily
when user is typing, but only when there is a small pause in the typing. This
makes it perfect for this kind of automatic filtering. When user has changed the
text, we'll just update the listing like in updateList method, but use the
current text as a filter for entries.

To keep the updateList method functional, it should also take consider the value
of the filterText field. Change the line fetching the customers into this:

[source,java]
  List<Customer> customers = service.findAll(filterText.getValue());

The search field can naturally be cleared with keyboard, but let's improve the
usability a bit and make a short exercise to compose better components from low
level Vaadin components. To add a clear button next to the text field, add
following lines:

[source,java]
----
Button clearFilterTextBtn = new Button(FontAwesome.TIMES);
clearFilterTextBtn.setDescription("Clear the current filter");
clearFilterTextBtn.addClickListener(e -> {
  filterText.clear();
  updateList();
});
----

Vaadin contains a set of built in icons, from which we here use the X icon,
which most users well recognize as a clear functionality. If we set the
description to a component, it will be shown as a tooltip for those users who
hover the mouse over the button and wonder what to do with it. In the click
listener we simply clear the text form the field and refresh the content of the
listing.

Vaadin contains lots of different kind of layouts. A simple way to align the
text field and button would be to use HorizontalLayout. An alternative way we
use here is using CssLayout, which is a lightweight layout that is easy to
customize with css. Even if you wouldn't want to play with css yourself, you can
many times use one of the existing style rules in the Valo theme. Following
snippet will create a nice compact "composition" of both the TextField and the
clear button:

[source,java]
----
CssLayout filtering = new CssLayout();
filtering.addComponents(filterText, clearFilterTextBtn);
filtering.setStyleName(ValoTheme.LAYOUT_COMPONENT_GROUP);
----

Finally, just add the composition to your main layout before the grid:

    layout.addComponents(filtering, grid);

If you wish, you can take an extra exercise and extract the composition of
CssLayout, TextField and the clear button into a re-usable class.

== Creating a form using Vaadin Designer

The form to edit Customer objects can be build using several methods. Visual
composition is an easy way to do it. Vaadin Designer is an Eclipse plugin that
you can install and do WYSIWYG editing for your Vaadin view code. We'll use it
to create the form and then hook the editing logic to it with Java. If you are
using another IDE or like more to code your UI's you can take an alternative
path of the tutorial, <<Creating a form using plain Java>> where you create the
form with plain Java code.

TODO installation instruction

image::pluginEclipseMarketPlace.png[Open Eclipse marketplace]

image::pluginEclipseMarketPlace2.png[Eclipse marketplace search]

image::pluginConfirmInstall.png[Confirm installation]

image::pluginCreateDesign.png[Create design]

TODO VIDEO how to create the CustomerFormDesign.html, otherwise it will
become too long, boring and error prone for users to repeat it

TODO discuss that .html files can be manually edited as well with the source,
mode, provide copy-pasteable "final state" for next step without issues

TODO extend CustomerForm form CustomerFormDesign, mostly the same as the rest
of <<Creating a form using plain Java>> chapter.

== Creating a form using plain Java

This is an alternative step to the <<Creating a form using Vaadin Designer>>,
where you'll build the form UI programmatically with plain Java.

Start by creating a new Java class with name CustomerForm. In Eclipse right
click on the "my.vaadin.app" package and choose "New -> Class". Type in name
"CustomerForm", define the super class as "com.vaadin.ui.FormLayout" and click
finish.

In the form we'll need editor fields for each property in our Customer domain
class. There are different kind of fields in Vaadin to edit different kind of
properties. In this example we'll use TextField, PopupDateField and
NativeSelect. Add following field declarations and action buttons as Java fields
to the CustomerForm:

[source,java]
----
TextField firstName = new TextField("First name");
TextField lastName = new TextField("Last name");
TextField email = new TextField("Email");
NativeSelect status = new NativeSelect("Status");
PopupDateField birthdate = new PopupDateField("Birthday");
Button save = new Button("Save");
Button delete = new Button("Delete");
----

We will also need a reference to the currently edited Customer object,
CustomerService and the MainUI that uses this class. Add these fields and a
basic constructor that accepts MainUI as a parameter as well:

----
CustomerService service = CustomerService.getInstance();
private Customer customer;
private MyUI parent;

public CustomerForm(MyUI myUI) {
  this.parent = myUI;

  setSizeUndefined();
  HorizontalLayout buttons = new HorizontalLayout(save, delete);
  buttons.setSpacing(true);
  addComponents(firstName, lastName, email, status, birthdate, buttons);
}
----

In the constructor we make the form naturally sized, add all fields to the FormLayout (from which we are
inheriting) and add action buttons to the bottom - side-by-side using
a HorizontalLayout. Although the form is not yet fully functional, you might want
to see how it looks like at this point. Add it as a field to the MyUI class:

    CustomerForm form = new CustomerForm(this);

Now let's modify the init method in MyUI to show the form. Let's wrap both the
Grid and the CustomerForm in a horizontal layout and configure the Grid to use
all available space more efficiently. Replace the line *layout.addComponents(filtering, grid);* with following:

[source,java]
----
HorizontalLayout main = new HorizontalLayout(grid, form);
main.setSpacing(true);
main.setWidth("100%");
grid.setSizeFull();
main.setExpandRatio(grid, 1);

layout.addComponents(filtering, main);
----

Let's get back to the CustomerForm and enhance it. The first thing we'll need is
to populate the options for the select. To add all enum values as valid
selections, add following line to the constructor:

[source,java]
   status.addItems(CustomerStatus.values());

Let's also improve the UX a bit. The most common thing your users will want to
do with this kind of form is to save it. Let's decorate the button with a style
name that makes it more prominent in the UI and give it a keyboard shortcut -
simply an enter hit in this case:

[source,java]
----
save.setStyleName(ValoTheme.BUTTON_PRIMARY);
save.setClickShortcut(KeyCode.ENTER);
----

Last step to finish our form is to create an API for the MainUI to pass a
Customer object the form should edit and add some logic to actually save
the UI. We'll start by creating a setter method for the Customer field. Just
type "setCus" in the body of the class and hit autocomplete (CTRL-SPACE) and
Eclipse will create you a method stub. Complete it with following declaration:

[source,java]
----
public void setCustomer(Customer customer) {
  this.customer = customer;
  BeanFieldGroup.bindFieldsUnbuffered(customer, this);

  // Show delete button for only customers already in the database
  delete.setVisible(customer.isPersisted());
  setVisible(true);
  firstName.selectAll();
}
----

The call to *BeanFieldGroup.bindFieldsUnbuffered* method will initialize all
similarly named editor fields in this form with their counterpart in the given
domain object. Also it will automatically update the values in the domain
objects as the corresponding field value changes in the UI. Note, that if the
naming convention don't fit for your needs, you can use PropertyId annotation on
fields to explicitly declare the edited property.

As a side effects, when a customer is selected for editing, we'll also want to
show the delete buttons for entities that actually are persisted, ensure the
form is visible and focus the first field to improve the UX.

The last thing we need to do is to handle save and delete button clicks. Add
following methods to the CustomerForm class:

[source,java]
----
private void delete() {
  service.delete(customer);
  parent.updateList();
}

protected void save() {
  service.save(customer);
  parent.updateList();
}
----

Finally we'll add listeners to buttons to call these methods. Adding these
simple lambda expression to the constructor will take care of that:

[source,java]
----
save.addClickListener(e->this.save());
delete.addClickListener(e->this.delete());
----

Note, that for a truly re-usable form component in a real life project, you'd
want to introduce an interface for the parent field or, event better, use event
system (e.g. CDI events) to completely decouple the components. We'll leave that
out of this tutorial for simplicity.

== Connecting the form to the application

We'll use the form in two use cases form the MyUI class: editing an existing
customer and creating a new one. By default we want it to be invisible, so lets
first hide it by default by adding this line to the constructor:

[source,java]
    form.setVisible(false);

To edit customers chosen from the Grid we'll use following click listener:

[source,java]
----
grid.addSelectionListener(event -> {
  if (event.getSelected().isEmpty()) {
    form.setVisible(false);
  } else {
    Customer customer = (Customer) event.getSelected().iterator().next();
    form.setCustomer(customer);
  }
});
----

So we simple take the selected row and pass the corresponding customer object to
the form we created in previous step. If the the selection is empty, we'll
simply hide the form.

To allow users to create new customer records, we'll add a simple "Add customer
button" to the top of the UI, right next to the filtering composition. In click
listener we first clear the selection from the listing and then instantiate a
new Customer object and pass it for the form for editing:

[source,java]
----
Button addCustomerBtn = new Button("Add new customer");
addCustomerBtn.addClickListener(e -> {
  grid.select(null);
  form.setCustomer(new Customer());
});
----

To add it beside our filtering composition, we can just use a HorizontalLayout
where we place both components and add that to the main layout instead of
filtering composition.

[source,java]
----
HorizontalLayout toolbar = new HorizontalLayout(filtering, addCustomerBtn);
toolbar.setSpacing(true);

layout.addComponents(toolbar, main);
----

The final UI looks like this:

IMAGE

You can also download TODO the final state of the tutorial from github.

== It works! What next?

Congratulations! Users can now create, read, update and delete customer records
stored in the demo backend and you have completed creating your first CRUD UI
with Vaadin.

If you are an experienced Java developer, you are probably already full of ideas
how you can use your existing skills and create new shiny web UIs for your
existing Java apps. If you want more ideas how to create real applications with
see for example Spring guide
http://spring.io/guides/gs/crud-with-vaadin/[Creating CRUD UI with Vaadin],
where you'll create a bit similar UI for an Spring Data JPA backend or some of
other pointers listed below:

 * TODO the full stack tutorial with Java EE 7 and Vaadin CDI
 * http://spring.io/guides/gs/crud-with-vaadin/[Creating CRUD UI with Vaadin]
 * Some Java EE example app
 * Directory, a source of awesome Vaadin extensions
 * Some theme building tutorial/book chapter
 * Using MVP pattern to structure your UI code TODO link somewhere
 * TODO figure out where to point users from here
